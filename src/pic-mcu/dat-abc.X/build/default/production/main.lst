CCS PCM C Compiler, Version 5.025, 8602               25-Mar-20 20:52

               Filename:   C:\Users\ngodi\MPLABXProjects\dat-abc.X\build\default\production\main.lst

               ROM used:   2725 words (33%)
                           Largest free fragment is 2048
               RAM used:   22 (6%) at main() level
                           54 (15%) worst case
               Stack used: 6 locations
               Stack size: 8

*
0000:  MOVLW  09
0001:  MOVWF  0A
0002:  GOTO   169
0003:  NOP
.................... /*  
....................  * File:   main.c 
....................  * Author: ngodinhduy 
....................  * 
....................  * Created on March 18, 2020, 9:45 PM 
....................  */ 
....................  
....................  
.................... #include <16F886.h> 
.................... //////////// Standard Header file for the PIC16F886 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F886 
0004:  DATA 0C,00
0005:  DATA 53,2A
0006:  DATA 41,29
0007:  DATA 54,00
0008:  DATA 0C,00
0009:  DATA C6,16
000A:  DATA 4F,27
000B:  DATA 00,01
000C:  DATA C6,16
000D:  DATA 4F,23
000E:  DATA 46,00
000F:  DATA CC,16
0010:  DATA 4F,27
0011:  DATA 00,01
0012:  DATA CC,16
0013:  DATA 4F,23
0014:  DATA 46,00
0015:  DATA 41,00
0016:  DATA 48,00
0017:  DATA 53,28
0018:  DATA AD,12
0019:  DATA 64,10
001A:  DATA 20,10
001B:  DATA 43,29
001C:  DATA AD,12
001D:  DATA 33,17
001E:  DATA 31,33
001F:  DATA 80,1E
*
01D3:  MOVF   0B,W
01D4:  MOVWF  36
01D5:  BCF    0B.7
01D6:  BSF    03.5
01D7:  BSF    03.6
01D8:  BSF    0C.7
01D9:  BSF    0C.0
01DA:  NOP
01DB:  NOP
01DC:  BCF    03.5
01DD:  BCF    03.6
01DE:  BTFSC  36.7
01DF:  BSF    0B.7
01E0:  BSF    03.6
01E1:  MOVF   0C,W
01E2:  ANDLW  7F
01E3:  BTFSC  03.2
01E4:  GOTO   227
01E5:  BCF    03.6
01E6:  MOVWF  36
01E7:  BSF    03.6
01E8:  MOVF   0D,W
01E9:  BCF    03.6
01EA:  MOVWF  37
01EB:  BSF    03.6
01EC:  MOVF   0F,W
01ED:  BCF    03.6
01EE:  MOVWF  38
01EF:  MOVF   36,W
01F0:  MOVWF  43
01F1:  CALL   1A7
01F2:  MOVF   37,W
01F3:  BSF    03.6
01F4:  MOVWF  0D
01F5:  BCF    03.6
01F6:  MOVF   38,W
01F7:  BSF    03.6
01F8:  MOVWF  0F
01F9:  BCF    03.6
01FA:  MOVF   0B,W
01FB:  MOVWF  39
01FC:  BCF    0B.7
01FD:  BSF    03.5
01FE:  BSF    03.6
01FF:  BSF    0C.7
0200:  BSF    0C.0
0201:  NOP
0202:  NOP
0203:  BCF    03.5
0204:  BCF    03.6
0205:  BTFSC  39.7
0206:  BSF    0B.7
0207:  BSF    03.6
0208:  RLF    0C,W
0209:  RLF    0E,W
020A:  ANDLW  7F
020B:  BTFSC  03.2
020C:  GOTO   227
020D:  BCF    03.6
020E:  MOVWF  36
020F:  BSF    03.6
0210:  MOVF   0D,W
0211:  BCF    03.6
0212:  MOVWF  37
0213:  BSF    03.6
0214:  MOVF   0F,W
0215:  BCF    03.6
0216:  MOVWF  38
0217:  MOVF   36,W
0218:  MOVWF  43
0219:  CALL   1A7
021A:  MOVF   37,W
021B:  BSF    03.6
021C:  MOVWF  0D
021D:  BCF    03.6
021E:  MOVF   38,W
021F:  BSF    03.6
0220:  MOVWF  0F
0221:  INCF   0D,F
0222:  BTFSC  03.2
0223:  INCF   0F,F
0224:  BCF    03.6
0225:  GOTO   1D3
0226:  BSF    03.6
0227:  BCF    03.6
0228:  RETURN
*
024B:  MOVF   0B,W
024C:  MOVWF  36
024D:  BCF    0B.7
024E:  BSF    03.5
024F:  BSF    03.6
0250:  BSF    0C.7
0251:  BSF    0C.0
0252:  NOP
0253:  NOP
0254:  BCF    03.5
0255:  BCF    03.6
0256:  BTFSC  36.7
0257:  BSF    0B.7
0258:  BSF    03.6
0259:  MOVF   0C,W
025A:  ANDLW  7F
025B:  BTFSC  03.2
025C:  GOTO   29F
025D:  BCF    03.6
025E:  MOVWF  36
025F:  BSF    03.6
0260:  MOVF   0D,W
0261:  BCF    03.6
0262:  MOVWF  37
0263:  BSF    03.6
0264:  MOVF   0F,W
0265:  BCF    03.6
0266:  MOVWF  38
0267:  MOVF   36,W
0268:  MOVWF  43
0269:  CALL   229
026A:  MOVF   37,W
026B:  BSF    03.6
026C:  MOVWF  0D
026D:  BCF    03.6
026E:  MOVF   38,W
026F:  BSF    03.6
0270:  MOVWF  0F
0271:  BCF    03.6
0272:  MOVF   0B,W
0273:  MOVWF  39
0274:  BCF    0B.7
0275:  BSF    03.5
0276:  BSF    03.6
0277:  BSF    0C.7
0278:  BSF    0C.0
0279:  NOP
027A:  NOP
027B:  BCF    03.5
027C:  BCF    03.6
027D:  BTFSC  39.7
027E:  BSF    0B.7
027F:  BSF    03.6
0280:  RLF    0C,W
0281:  RLF    0E,W
0282:  ANDLW  7F
0283:  BTFSC  03.2
0284:  GOTO   29F
0285:  BCF    03.6
0286:  MOVWF  36
0287:  BSF    03.6
0288:  MOVF   0D,W
0289:  BCF    03.6
028A:  MOVWF  37
028B:  BSF    03.6
028C:  MOVF   0F,W
028D:  BCF    03.6
028E:  MOVWF  38
028F:  MOVF   36,W
0290:  MOVWF  43
0291:  CALL   229
0292:  MOVF   37,W
0293:  BSF    03.6
0294:  MOVWF  0D
0295:  BCF    03.6
0296:  MOVF   38,W
0297:  BSF    03.6
0298:  MOVWF  0F
0299:  INCF   0D,F
029A:  BTFSC  03.2
029B:  INCF   0F,F
029C:  BCF    03.6
029D:  GOTO   24B
029E:  BSF    03.6
029F:  BCF    03.6
02A0:  BSF    0A.3
02A1:  BCF    0A.4
02A2:  GOTO   1A9 (RETURN)
*
039A:  MOVLW  8E
039B:  MOVWF  77
039C:  MOVF   40,W
039D:  MOVWF  78
039E:  MOVF   3F,W
039F:  MOVWF  79
03A0:  CLRF   7A
03A1:  BTFSS  40.7
03A2:  GOTO   3A8
03A3:  COMF   78,F
03A4:  COMF   79,F
03A5:  INCF   79,F
03A6:  BTFSC  03.2
03A7:  INCF   78,F
03A8:  MOVF   78,F
03A9:  BTFSS  03.2
03AA:  GOTO   3B5
03AB:  MOVF   79,W
03AC:  MOVWF  78
03AD:  CLRF   79
03AE:  MOVLW  08
03AF:  SUBWF  77,F
03B0:  MOVF   78,F
03B1:  BTFSS  03.2
03B2:  GOTO   3B5
03B3:  CLRF   77
03B4:  GOTO   3BE
03B5:  BCF    03.0
03B6:  BTFSC  78.7
03B7:  GOTO   3BC
03B8:  RLF    79,F
03B9:  RLF    78,F
03BA:  DECF   77,F
03BB:  GOTO   3B5
03BC:  BTFSS  40.7
03BD:  BCF    78.7
*
03D3:  MOVF   43,W
03D4:  BTFSC  03.2
03D5:  GOTO   498
03D6:  MOVWF  4F
03D7:  MOVF   47,W
03D8:  BTFSC  03.2
03D9:  GOTO   498
03DA:  SUBWF  4F,F
03DB:  BTFSS  03.0
03DC:  GOTO   3E2
03DD:  MOVLW  7F
03DE:  ADDWF  4F,F
03DF:  BTFSC  03.0
03E0:  GOTO   498
03E1:  GOTO   3E8
03E2:  MOVLW  81
03E3:  SUBWF  4F,F
03E4:  BTFSS  03.0
03E5:  GOTO   498
03E6:  BTFSC  03.2
03E7:  GOTO   498
03E8:  MOVF   4F,W
03E9:  MOVWF  77
03EA:  CLRF   78
03EB:  CLRF   79
03EC:  CLRF   7A
03ED:  CLRF   4E
03EE:  MOVF   44,W
03EF:  MOVWF  4D
03F0:  BSF    4D.7
03F1:  MOVF   45,W
03F2:  MOVWF  4C
03F3:  MOVF   46,W
03F4:  MOVWF  4B
03F5:  MOVLW  19
03F6:  MOVWF  4F
03F7:  MOVF   4A,W
03F8:  SUBWF  4B,F
03F9:  BTFSC  03.0
03FA:  GOTO   40B
03FB:  MOVLW  01
03FC:  SUBWF  4C,F
03FD:  BTFSC  03.0
03FE:  GOTO   40B
03FF:  SUBWF  4D,F
0400:  BTFSC  03.0
0401:  GOTO   40B
0402:  SUBWF  4E,F
0403:  BTFSC  03.0
0404:  GOTO   40B
0405:  INCF   4E,F
0406:  INCF   4D,F
0407:  INCF   4C,F
0408:  MOVF   4A,W
0409:  ADDWF  4B,F
040A:  GOTO   43D
040B:  MOVF   49,W
040C:  SUBWF  4C,F
040D:  BTFSC  03.0
040E:  GOTO   426
040F:  MOVLW  01
0410:  SUBWF  4D,F
0411:  BTFSC  03.0
0412:  GOTO   426
0413:  SUBWF  4E,F
0414:  BTFSC  03.0
0415:  GOTO   426
0416:  INCF   4E,F
0417:  INCF   4D,F
0418:  MOVF   49,W
0419:  ADDWF  4C,F
041A:  MOVF   4A,W
041B:  ADDWF  4B,F
041C:  BTFSS  03.0
041D:  GOTO   43D
041E:  INCF   4C,F
041F:  BTFSS  03.2
0420:  GOTO   43D
0421:  INCF   4D,F
0422:  BTFSS  03.2
0423:  GOTO   43D
0424:  INCF   4E,F
0425:  GOTO   43D
0426:  MOVF   48,W
0427:  IORLW  80
0428:  SUBWF  4D,F
0429:  BTFSC  03.0
042A:  GOTO   43C
042B:  MOVLW  01
042C:  SUBWF  4E,F
042D:  BTFSC  03.0
042E:  GOTO   43C
042F:  INCF   4E,F
0430:  MOVF   48,W
0431:  IORLW  80
0432:  ADDWF  4D,F
0433:  MOVF   49,W
0434:  ADDWF  4C,F
0435:  BTFSS  03.0
0436:  GOTO   41A
0437:  INCF   4D,F
0438:  BTFSS  03.2
0439:  GOTO   41A
043A:  INCF   4E,F
043B:  GOTO   41A
043C:  BSF    7A.0
043D:  DECFSZ 4F,F
043E:  GOTO   440
043F:  GOTO   44B
0440:  BCF    03.0
0441:  RLF    4B,F
0442:  RLF    4C,F
0443:  RLF    4D,F
0444:  RLF    4E,F
0445:  BCF    03.0
0446:  RLF    7A,F
0447:  RLF    79,F
0448:  RLF    78,F
0449:  RLF    50,F
044A:  GOTO   3F7
044B:  BTFSS  50.0
044C:  GOTO   453
044D:  BCF    03.0
044E:  RRF    78,F
044F:  RRF    79,F
0450:  RRF    7A,F
0451:  RRF    50,F
0452:  GOTO   456
0453:  DECF   77,F
0454:  BTFSC  03.2
0455:  GOTO   498
0456:  BTFSC  50.7
0457:  GOTO   47F
0458:  BCF    03.0
0459:  RLF    4B,F
045A:  RLF    4C,F
045B:  RLF    4D,F
045C:  RLF    4E,F
045D:  MOVF   4A,W
045E:  SUBWF  4B,F
045F:  BTFSC  03.0
0460:  GOTO   46B
0461:  MOVLW  01
0462:  SUBWF  4C,F
0463:  BTFSC  03.0
0464:  GOTO   46B
0465:  SUBWF  4D,F
0466:  BTFSC  03.0
0467:  GOTO   46B
0468:  SUBWF  4E,F
0469:  BTFSS  03.0
046A:  GOTO   48E
046B:  MOVF   49,W
046C:  SUBWF  4C,F
046D:  BTFSC  03.0
046E:  GOTO   476
046F:  MOVLW  01
0470:  SUBWF  4D,F
0471:  BTFSC  03.0
0472:  GOTO   476
0473:  SUBWF  4E,F
0474:  BTFSS  03.0
0475:  GOTO   48E
0476:  MOVF   48,W
0477:  IORLW  80
0478:  SUBWF  4D,F
0479:  BTFSC  03.0
047A:  GOTO   47F
047B:  MOVLW  01
047C:  SUBWF  4E,F
047D:  BTFSS  03.0
047E:  GOTO   48E
047F:  INCF   7A,F
0480:  BTFSS  03.2
0481:  GOTO   48E
0482:  INCF   79,F
0483:  BTFSS  03.2
0484:  GOTO   48E
0485:  INCF   78,F
0486:  BTFSS  03.2
0487:  GOTO   48E
0488:  INCF   77,F
0489:  BTFSC  03.2
048A:  GOTO   498
048B:  RRF    78,F
048C:  RRF    79,F
048D:  RRF    7A,F
048E:  MOVF   44,W
048F:  MOVWF  4F
0490:  MOVF   48,W
0491:  XORWF  4F,F
0492:  BTFSS  4F.7
0493:  GOTO   496
0494:  BSF    78.7
0495:  GOTO   49C
0496:  BCF    78.7
0497:  GOTO   49C
0498:  CLRF   77
0499:  CLRF   78
049A:  CLRF   79
049B:  CLRF   7A
*
04B7:  MOVLW  8E
04B8:  MOVWF  77
04B9:  MOVF   37,W
04BA:  MOVWF  78
04BB:  MOVF   36,W
04BC:  MOVWF  79
04BD:  CLRF   7A
04BE:  MOVF   78,F
04BF:  BTFSS  03.2
04C0:  GOTO   4CB
04C1:  MOVF   79,W
04C2:  MOVWF  78
04C3:  CLRF   79
04C4:  MOVLW  08
04C5:  SUBWF  77,F
04C6:  MOVF   78,F
04C7:  BTFSS  03.2
04C8:  GOTO   4CB
04C9:  CLRF   77
04CA:  GOTO   4D3
04CB:  BCF    03.0
04CC:  BTFSC  78.7
04CD:  GOTO   4D2
04CE:  RLF    79,F
04CF:  RLF    78,F
04D0:  DECF   77,F
04D1:  GOTO   4CB
04D2:  BCF    78.7
*
04E3:  MOVF   37,W
04E4:  MOVWF  3E
04E5:  MOVF   3B,W
04E6:  XORWF  3E,F
04E7:  BTFSS  3E.7
04E8:  GOTO   4EE
04E9:  BCF    03.2
04EA:  BCF    03.0
04EB:  BTFSC  37.7
04EC:  BSF    03.0
04ED:  GOTO   521
04EE:  MOVF   37,W
04EF:  MOVWF  3E
04F0:  MOVF   3A,W
04F1:  MOVWF  3F
04F2:  MOVF   36,W
04F3:  SUBWF  3F,F
04F4:  BTFSC  03.2
04F5:  GOTO   4FC
04F6:  BTFSS  3E.7
04F7:  GOTO   521
04F8:  MOVF   03,W
04F9:  XORLW  01
04FA:  MOVWF  03
04FB:  GOTO   521
04FC:  MOVF   3B,W
04FD:  MOVWF  3F
04FE:  MOVF   37,W
04FF:  SUBWF  3F,F
0500:  BTFSC  03.2
0501:  GOTO   508
0502:  BTFSS  3E.7
0503:  GOTO   521
0504:  MOVF   03,W
0505:  XORLW  01
0506:  MOVWF  03
0507:  GOTO   521
0508:  MOVF   3C,W
0509:  MOVWF  3F
050A:  MOVF   38,W
050B:  SUBWF  3F,F
050C:  BTFSC  03.2
050D:  GOTO   514
050E:  BTFSS  3E.7
050F:  GOTO   521
0510:  MOVF   03,W
0511:  XORLW  01
0512:  MOVWF  03
0513:  GOTO   521
0514:  MOVF   3D,W
0515:  MOVWF  3F
0516:  MOVF   39,W
0517:  SUBWF  3F,F
0518:  BTFSC  03.2
0519:  GOTO   520
051A:  BTFSS  3E.7
051B:  GOTO   521
051C:  MOVF   03,W
051D:  XORLW  01
051E:  MOVWF  03
051F:  GOTO   521
0520:  BCF    03.0
*
0550:  MOVF   3D,W
0551:  CLRF   78
0552:  SUBWF  3C,W
0553:  BTFSC  03.0
0554:  GOTO   558
0555:  MOVF   3C,W
0556:  MOVWF  77
0557:  GOTO   564
0558:  CLRF   77
0559:  MOVLW  08
055A:  MOVWF  3E
055B:  RLF    3C,F
055C:  RLF    77,F
055D:  MOVF   3D,W
055E:  SUBWF  77,W
055F:  BTFSC  03.0
0560:  MOVWF  77
0561:  RLF    78,F
0562:  DECFSZ 3E,F
0563:  GOTO   55B
0564:  RETURN
0565:  MOVF   43,W
0566:  BTFSC  03.2
0567:  GOTO   5D5
0568:  MOVWF  4B
0569:  MOVF   47,W
056A:  BTFSC  03.2
056B:  GOTO   5D5
056C:  ADDWF  4B,F
056D:  BTFSC  03.0
056E:  GOTO   576
056F:  MOVLW  7F
0570:  SUBWF  4B,F
0571:  BTFSS  03.0
0572:  GOTO   5D5
0573:  BTFSC  03.2
0574:  GOTO   5D5
0575:  GOTO   57A
0576:  MOVLW  81
0577:  ADDWF  4B,F
0578:  BTFSC  03.0
0579:  GOTO   5D5
057A:  MOVF   4B,W
057B:  MOVWF  77
057C:  CLRF   78
057D:  CLRF   79
057E:  CLRF   7A
057F:  MOVF   44,W
0580:  MOVWF  4F
0581:  BSF    4F.7
0582:  MOVF   45,W
0583:  MOVWF  4E
0584:  MOVF   46,W
0585:  MOVWF  4D
0586:  MOVLW  18
0587:  MOVWF  4B
0588:  CLRF   4C
0589:  BTFSS  4D.0
058A:  GOTO   5A3
058B:  MOVF   4A,W
058C:  ADDWF  7A,F
058D:  BTFSS  03.0
058E:  GOTO   595
058F:  INCF   79,F
0590:  BTFSS  03.2
0591:  GOTO   595
0592:  INCF   78,F
0593:  BTFSC  03.2
0594:  BSF    4C.7
0595:  MOVF   49,W
0596:  ADDWF  79,F
0597:  BTFSS  03.0
0598:  GOTO   59C
0599:  INCF   78,F
059A:  BTFSC  03.2
059B:  BSF    4C.7
059C:  MOVF   48,W
059D:  MOVWF  45
059E:  BSF    45.7
059F:  MOVF   45,W
05A0:  ADDWF  78,F
05A1:  BTFSC  03.0
05A2:  BSF    4C.7
05A3:  RLF    4C,F
05A4:  RRF    78,F
05A5:  RRF    79,F
05A6:  RRF    7A,F
05A7:  RRF    4F,F
05A8:  RRF    4E,F
05A9:  RRF    4D,F
05AA:  BCF    03.0
05AB:  DECFSZ 4B,F
05AC:  GOTO   588
05AD:  MOVLW  01
05AE:  ADDWF  77,F
05AF:  BTFSC  03.0
05B0:  GOTO   5D5
05B1:  BTFSC  78.7
05B2:  GOTO   5BA
05B3:  RLF    4F,F
05B4:  RLF    7A,F
05B5:  RLF    79,F
05B6:  RLF    78,F
05B7:  DECF   77,F
05B8:  BTFSC  03.2
05B9:  GOTO   5D5
05BA:  BTFSS  4F.7
05BB:  GOTO   5CB
05BC:  INCF   7A,F
05BD:  BTFSS  03.2
05BE:  GOTO   5CB
05BF:  INCF   79,F
05C0:  BTFSS  03.2
05C1:  GOTO   5CB
05C2:  INCF   78,F
05C3:  BTFSS  03.2
05C4:  GOTO   5CB
05C5:  RRF    78,F
05C6:  RRF    79,F
05C7:  RRF    7A,F
05C8:  INCF   77,F
05C9:  BTFSC  03.2
05CA:  GOTO   5D5
05CB:  MOVF   44,W
05CC:  MOVWF  4C
05CD:  MOVF   48,W
05CE:  XORWF  4C,F
05CF:  BTFSS  4C.7
05D0:  GOTO   5D3
05D1:  BSF    78.7
05D2:  GOTO   5D9
05D3:  BCF    78.7
05D4:  GOTO   5D9
05D5:  CLRF   77
05D6:  CLRF   78
05D7:  CLRF   79
05D8:  CLRF   7A
05D9:  RETURN
05DA:  MOVF   43,W
05DB:  SUBLW  B6
05DC:  MOVWF  43
05DD:  CLRF   7A
05DE:  MOVF   44,W
05DF:  MOVWF  47
05E0:  BSF    44.7
05E1:  BCF    03.0
05E2:  RRF    44,F
05E3:  RRF    45,F
05E4:  RRF    46,F
05E5:  RRF    7A,F
05E6:  RRF    79,F
05E7:  RRF    78,F
05E8:  RRF    77,F
05E9:  DECFSZ 43,F
05EA:  GOTO   5E1
05EB:  BTFSS  47.7
05EC:  GOTO   5F8
05ED:  COMF   77,F
05EE:  COMF   78,F
05EF:  COMF   79,F
05F0:  COMF   7A,F
05F1:  INCF   77,F
05F2:  BTFSC  03.2
05F3:  INCF   78,F
05F4:  BTFSC  03.2
05F5:  INCF   79,F
05F6:  BTFSC  03.2
05F7:  INCF   7A,F
05F8:  RETURN
05F9:  BTFSC  03.1
05FA:  GOTO   5FE
05FB:  MOVLW  4B
05FC:  MOVWF  04
05FD:  BCF    03.7
05FE:  CLRF   77
05FF:  CLRF   78
0600:  CLRF   79
0601:  CLRF   7A
0602:  CLRF   4B
0603:  CLRF   4C
0604:  CLRF   4D
0605:  CLRF   4E
0606:  MOVF   4A,W
0607:  IORWF  49,W
0608:  IORWF  48,W
0609:  IORWF  47,W
060A:  BTFSC  03.2
060B:  GOTO   63C
060C:  MOVLW  20
060D:  MOVWF  4F
060E:  BCF    03.0
060F:  RLF    43,F
0610:  RLF    44,F
0611:  RLF    45,F
0612:  RLF    46,F
0613:  RLF    4B,F
0614:  RLF    4C,F
0615:  RLF    4D,F
0616:  RLF    4E,F
0617:  MOVF   4A,W
0618:  SUBWF  4E,W
0619:  BTFSS  03.2
061A:  GOTO   625
061B:  MOVF   49,W
061C:  SUBWF  4D,W
061D:  BTFSS  03.2
061E:  GOTO   625
061F:  MOVF   48,W
0620:  SUBWF  4C,W
0621:  BTFSS  03.2
0622:  GOTO   625
0623:  MOVF   47,W
0624:  SUBWF  4B,W
0625:  BTFSS  03.0
0626:  GOTO   636
0627:  MOVF   47,W
0628:  SUBWF  4B,F
0629:  MOVF   48,W
062A:  BTFSS  03.0
062B:  INCFSZ 48,W
062C:  SUBWF  4C,F
062D:  MOVF   49,W
062E:  BTFSS  03.0
062F:  INCFSZ 49,W
0630:  SUBWF  4D,F
0631:  MOVF   4A,W
0632:  BTFSS  03.0
0633:  INCFSZ 4A,W
0634:  SUBWF  4E,F
0635:  BSF    03.0
0636:  RLF    77,F
0637:  RLF    78,F
0638:  RLF    79,F
0639:  RLF    7A,F
063A:  DECFSZ 4F,F
063B:  GOTO   60E
063C:  MOVF   4B,W
063D:  MOVWF  00
063E:  INCF   04,F
063F:  MOVF   4C,W
0640:  MOVWF  00
0641:  INCF   04,F
0642:  MOVF   4D,W
0643:  MOVWF  00
0644:  INCF   04,F
0645:  MOVF   4E,W
0646:  MOVWF  00
0647:  RETURN
0648:  MOVF   04,W
0649:  MOVWF  3B
064A:  MOVF   3A,W
064B:  MOVWF  3D
064C:  BTFSC  03.2
064D:  GOTO   667
064E:  MOVF   39,W
064F:  MOVWF  46
0650:  MOVF   38,W
0651:  MOVWF  45
0652:  MOVF   37,W
0653:  MOVWF  44
0654:  MOVF   36,W
0655:  MOVWF  43
0656:  CLRF   4A
0657:  CLRF   49
0658:  MOVLW  20
0659:  MOVWF  48
065A:  MOVLW  82
065B:  MOVWF  47
065C:  CALL   565
065D:  MOVF   7A,W
065E:  MOVWF  39
065F:  MOVF   79,W
0660:  MOVWF  38
0661:  MOVF   78,W
0662:  MOVWF  37
0663:  MOVF   77,W
0664:  MOVWF  36
0665:  DECFSZ 3D,F
0666:  GOTO   64E
0667:  MOVF   39,W
0668:  MOVWF  46
0669:  MOVF   38,W
066A:  MOVWF  45
066B:  MOVF   37,W
066C:  MOVWF  44
066D:  MOVF   36,W
066E:  MOVWF  43
066F:  CALL   5DA
0670:  MOVF   7A,W
0671:  MOVWF  39
0672:  MOVF   79,W
0673:  MOVWF  38
0674:  MOVF   78,W
0675:  MOVWF  37
0676:  MOVF   77,W
0677:  MOVWF  36
0678:  BTFSS  39.7
0679:  GOTO   687
067A:  DECF   3B,F
067B:  BSF    3B.5
067C:  COMF   36,F
067D:  COMF   37,F
067E:  COMF   38,F
067F:  COMF   39,F
0680:  INCF   36,F
0681:  BTFSC  03.2
0682:  INCF   37,F
0683:  BTFSC  03.2
0684:  INCF   38,F
0685:  BTFSC  03.2
0686:  INCF   39,F
0687:  MOVLW  3B
0688:  MOVWF  42
0689:  MOVLW  9A
068A:  MOVWF  41
068B:  MOVLW  CA
068C:  MOVWF  40
068D:  CLRF   3F
068E:  MOVLW  0A
068F:  MOVWF  3D
0690:  MOVF   3A,W
0691:  BTFSC  03.2
0692:  INCF   3B,F
0693:  BSF    03.1
0694:  MOVLW  36
0695:  MOVWF  04
0696:  BCF    03.7
0697:  MOVF   39,W
0698:  MOVWF  46
0699:  MOVF   38,W
069A:  MOVWF  45
069B:  MOVF   37,W
069C:  MOVWF  44
069D:  MOVF   36,W
069E:  MOVWF  43
069F:  MOVF   42,W
06A0:  MOVWF  4A
06A1:  MOVF   41,W
06A2:  MOVWF  49
06A3:  MOVF   40,W
06A4:  MOVWF  48
06A5:  MOVF   3F,W
06A6:  MOVWF  47
06A7:  CALL   5F9
06A8:  MOVF   78,W
06A9:  MOVF   77,F
06AA:  BTFSS  03.2
06AB:  GOTO   6BF
06AC:  INCF   3A,W
06AD:  SUBWF  3D,W
06AE:  BTFSC  03.2
06AF:  GOTO   6BF
06B0:  MOVF   3B,W
06B1:  BTFSC  03.2
06B2:  GOTO   6C1
06B3:  ANDLW  0F
06B4:  SUBWF  3D,W
06B5:  BTFSC  03.2
06B6:  GOTO   6B9
06B7:  BTFSC  03.0
06B8:  GOTO   6F1
06B9:  BTFSC  3B.7
06BA:  GOTO   6F1
06BB:  BTFSC  3B.6
06BC:  GOTO   6C1
06BD:  MOVLW  20
06BE:  GOTO   6ED
06BF:  MOVLW  20
06C0:  ANDWF  3B,F
06C1:  BTFSS  3B.5
06C2:  GOTO   6CF
06C3:  BCF    3B.5
06C4:  MOVF   3A,W
06C5:  BTFSS  03.2
06C6:  DECF   3B,F
06C7:  MOVF   77,W
06C8:  MOVWF  3B
06C9:  MOVLW  2D
06CA:  MOVWF  43
06CB:  CALL   1A7
06CC:  MOVF   3B,W
06CD:  MOVWF  77
06CE:  CLRF   3B
06CF:  MOVF   3A,W
06D0:  SUBWF  3D,W
06D1:  BTFSS  03.2
06D2:  GOTO   6DD
06D3:  MOVF   77,W
06D4:  MOVWF  3B
06D5:  MOVLW  2E
06D6:  MOVWF  43
06D7:  CALL   1A7
06D8:  MOVF   3B,W
06D9:  MOVWF  77
06DA:  MOVLW  20
06DB:  ANDWF  3B,F
06DC:  MOVLW  00
06DD:  MOVLW  30
06DE:  BTFSS  3B.5
06DF:  GOTO   6ED
06E0:  BCF    3B.5
06E1:  MOVF   3A,W
06E2:  BTFSS  03.2
06E3:  DECF   3B,F
06E4:  MOVF   77,W
06E5:  MOVWF  3B
06E6:  MOVLW  2D
06E7:  MOVWF  43
06E8:  CALL   1A7
06E9:  MOVF   3B,W
06EA:  MOVWF  77
06EB:  CLRF   3B
06EC:  MOVLW  30
06ED:  ADDWF  77,F
06EE:  MOVF   77,W
06EF:  MOVWF  43
06F0:  CALL   1A7
06F1:  BCF    03.1
06F2:  MOVF   42,W
06F3:  MOVWF  46
06F4:  MOVF   41,W
06F5:  MOVWF  45
06F6:  MOVF   40,W
06F7:  MOVWF  44
06F8:  MOVF   3F,W
06F9:  MOVWF  43
06FA:  CLRF   4A
06FB:  CLRF   49
06FC:  CLRF   48
06FD:  MOVLW  0A
06FE:  MOVWF  47
06FF:  CALL   5F9
0700:  MOVF   7A,W
0701:  MOVWF  42
0702:  MOVF   79,W
0703:  MOVWF  41
0704:  MOVF   78,W
0705:  MOVWF  40
0706:  MOVF   77,W
0707:  MOVWF  3F
0708:  DECFSZ 3D,F
0709:  GOTO   693
070A:  BSF    0A.3
070B:  BCF    0A.4
070C:  GOTO   153 (RETURN)
070D:  MOVF   04,W
070E:  MOVWF  3B
070F:  MOVF   3A,W
0710:  MOVWF  3D
0711:  BTFSC  03.2
0712:  GOTO   72C
0713:  MOVF   39,W
0714:  MOVWF  46
0715:  MOVF   38,W
0716:  MOVWF  45
0717:  MOVF   37,W
0718:  MOVWF  44
0719:  MOVF   36,W
071A:  MOVWF  43
071B:  CLRF   4A
071C:  CLRF   49
071D:  MOVLW  20
071E:  MOVWF  48
071F:  MOVLW  82
0720:  MOVWF  47
0721:  CALL   565
0722:  MOVF   7A,W
0723:  MOVWF  39
0724:  MOVF   79,W
0725:  MOVWF  38
0726:  MOVF   78,W
0727:  MOVWF  37
0728:  MOVF   77,W
0729:  MOVWF  36
072A:  DECFSZ 3D,F
072B:  GOTO   713
072C:  MOVF   39,W
072D:  MOVWF  46
072E:  MOVF   38,W
072F:  MOVWF  45
0730:  MOVF   37,W
0731:  MOVWF  44
0732:  MOVF   36,W
0733:  MOVWF  43
0734:  CALL   5DA
0735:  MOVF   7A,W
0736:  MOVWF  39
0737:  MOVF   79,W
0738:  MOVWF  38
0739:  MOVF   78,W
073A:  MOVWF  37
073B:  MOVF   77,W
073C:  MOVWF  36
073D:  BTFSS  39.7
073E:  GOTO   74C
073F:  DECF   3B,F
0740:  BSF    3B.5
0741:  COMF   36,F
0742:  COMF   37,F
0743:  COMF   38,F
0744:  COMF   39,F
0745:  INCF   36,F
0746:  BTFSC  03.2
0747:  INCF   37,F
0748:  BTFSC  03.2
0749:  INCF   38,F
074A:  BTFSC  03.2
074B:  INCF   39,F
074C:  MOVLW  3B
074D:  MOVWF  42
074E:  MOVLW  9A
074F:  MOVWF  41
0750:  MOVLW  CA
0751:  MOVWF  40
0752:  CLRF   3F
0753:  MOVLW  0A
0754:  MOVWF  3D
0755:  MOVF   3A,W
0756:  BTFSC  03.2
0757:  INCF   3B,F
0758:  BSF    03.1
0759:  MOVLW  36
075A:  MOVWF  04
075B:  BCF    03.7
075C:  MOVF   39,W
075D:  MOVWF  46
075E:  MOVF   38,W
075F:  MOVWF  45
0760:  MOVF   37,W
0761:  MOVWF  44
0762:  MOVF   36,W
0763:  MOVWF  43
0764:  MOVF   42,W
0765:  MOVWF  4A
0766:  MOVF   41,W
0767:  MOVWF  49
0768:  MOVF   40,W
0769:  MOVWF  48
076A:  MOVF   3F,W
076B:  MOVWF  47
076C:  CALL   5F9
076D:  MOVF   78,W
076E:  MOVF   77,F
076F:  BTFSS  03.2
0770:  GOTO   784
0771:  INCF   3A,W
0772:  SUBWF  3D,W
0773:  BTFSC  03.2
0774:  GOTO   784
0775:  MOVF   3B,W
0776:  BTFSC  03.2
0777:  GOTO   786
0778:  ANDLW  0F
0779:  SUBWF  3D,W
077A:  BTFSC  03.2
077B:  GOTO   77E
077C:  BTFSC  03.0
077D:  GOTO   7B6
077E:  BTFSC  3B.7
077F:  GOTO   7B6
0780:  BTFSC  3B.6
0781:  GOTO   786
0782:  MOVLW  20
0783:  GOTO   7B2
0784:  MOVLW  20
0785:  ANDWF  3B,F
0786:  BTFSS  3B.5
0787:  GOTO   794
0788:  BCF    3B.5
0789:  MOVF   3A,W
078A:  BTFSS  03.2
078B:  DECF   3B,F
078C:  MOVF   77,W
078D:  MOVWF  3B
078E:  MOVLW  2D
078F:  MOVWF  43
0790:  CALL   229
0791:  MOVF   3B,W
0792:  MOVWF  77
0793:  CLRF   3B
0794:  MOVF   3A,W
0795:  SUBWF  3D,W
0796:  BTFSS  03.2
0797:  GOTO   7A2
0798:  MOVF   77,W
0799:  MOVWF  3B
079A:  MOVLW  2E
079B:  MOVWF  43
079C:  CALL   229
079D:  MOVF   3B,W
079E:  MOVWF  77
079F:  MOVLW  20
07A0:  ANDWF  3B,F
07A1:  MOVLW  00
07A2:  MOVLW  30
07A3:  BTFSS  3B.5
07A4:  GOTO   7B2
07A5:  BCF    3B.5
07A6:  MOVF   3A,W
07A7:  BTFSS  03.2
07A8:  DECF   3B,F
07A9:  MOVF   77,W
07AA:  MOVWF  3B
07AB:  MOVLW  2D
07AC:  MOVWF  43
07AD:  CALL   229
07AE:  MOVF   3B,W
07AF:  MOVWF  77
07B0:  CLRF   3B
07B1:  MOVLW  30
07B2:  ADDWF  77,F
07B3:  MOVF   77,W
07B4:  MOVWF  43
07B5:  CALL   229
07B6:  BCF    03.1
07B7:  MOVF   42,W
07B8:  MOVWF  46
07B9:  MOVF   41,W
07BA:  MOVWF  45
07BB:  MOVF   40,W
07BC:  MOVWF  44
07BD:  MOVF   3F,W
07BE:  MOVWF  43
07BF:  CLRF   4A
07C0:  CLRF   49
07C1:  CLRF   48
07C2:  MOVLW  0A
07C3:  MOVWF  47
07C4:  CALL   5F9
07C5:  MOVF   7A,W
07C6:  MOVWF  42
07C7:  MOVF   79,W
07C8:  MOVWF  41
07C9:  MOVF   78,W
07CA:  MOVWF  40
07CB:  MOVF   77,W
07CC:  MOVWF  3F
07CD:  DECFSZ 3D,F
07CE:  GOTO   758
07CF:  BSF    0A.3
07D0:  BCF    0A.4
07D1:  GOTO   162 (RETURN)
*
0880:  MOVLW  20
0881:  BTFSS  37.4
0882:  MOVLW  30
0883:  MOVWF  38
0884:  MOVF   36,W
0885:  MOVWF  77
0886:  BTFSS  36.7
0887:  GOTO   090
0888:  COMF   77,F
0889:  INCF   77,F
088A:  MOVF   77,W
088B:  MOVWF  36
088C:  MOVLW  2D
088D:  MOVWF  38
088E:  BSF    37.7
088F:  BSF    37.0
0890:  MOVF   36,W
0891:  MOVWF  3C
0892:  MOVLW  64
0893:  MOVWF  3D
0894:  BCF    0A.3
0895:  CALL   550
0896:  BSF    0A.3
0897:  MOVF   77,W
0898:  MOVWF  36
0899:  MOVLW  30
089A:  ADDWF  78,W
089B:  MOVWF  39
089C:  MOVF   36,W
089D:  MOVWF  3C
089E:  MOVLW  0A
089F:  MOVWF  3D
08A0:  BCF    0A.3
08A1:  CALL   550
08A2:  BSF    0A.3
08A3:  MOVLW  30
08A4:  ADDWF  77,W
08A5:  MOVWF  3B
08A6:  MOVLW  30
08A7:  ADDWF  78,W
08A8:  MOVWF  3A
08A9:  MOVF   38,W
08AA:  MOVWF  77
08AB:  MOVLW  30
08AC:  SUBWF  39,W
08AD:  BTFSC  03.2
08AE:  GOTO   0B3
08AF:  BSF    37.1
08B0:  BTFSC  37.7
08B1:  BSF    37.2
08B2:  GOTO   0C7
08B3:  MOVF   38,W
08B4:  MOVWF  39
08B5:  MOVLW  20
08B6:  MOVWF  38
08B7:  MOVLW  30
08B8:  SUBWF  3A,W
08B9:  BTFSC  03.2
08BA:  GOTO   0BF
08BB:  BSF    37.0
08BC:  BTFSC  37.7
08BD:  BSF    37.1
08BE:  GOTO   0C7
08BF:  BTFSS  03.2
08C0:  BSF    37.0
08C1:  BTFSS  03.2
08C2:  GOTO   0C7
08C3:  MOVF   39,W
08C4:  MOVWF  3A
08C5:  MOVLW  20
08C6:  MOVWF  39
08C7:  BTFSC  37.2
08C8:  GOTO   0CE
08C9:  BTFSC  37.1
08CA:  GOTO   0D3
08CB:  BTFSC  37.0
08CC:  GOTO   0D8
08CD:  GOTO   0DD
08CE:  MOVF   38,W
08CF:  MOVWF  43
08D0:  BCF    0A.3
08D1:  CALL   1A7
08D2:  BSF    0A.3
08D3:  MOVF   39,W
08D4:  MOVWF  43
08D5:  BCF    0A.3
08D6:  CALL   1A7
08D7:  BSF    0A.3
08D8:  MOVF   3A,W
08D9:  MOVWF  43
08DA:  BCF    0A.3
08DB:  CALL   1A7
08DC:  BSF    0A.3
08DD:  MOVF   3B,W
08DE:  MOVWF  43
08DF:  BCF    0A.3
08E0:  CALL   1A7
08E1:  BSF    0A.3
*
08EB:  MOVF   0B,W
08EC:  MOVWF  37
08ED:  BCF    0B.7
08EE:  BSF    03.5
08EF:  BSF    03.6
08F0:  BSF    0C.7
08F1:  BSF    0C.0
08F2:  NOP
08F3:  NOP
08F4:  BCF    03.5
08F5:  BCF    03.6
08F6:  BTFSC  37.7
08F7:  BSF    0B.7
08F8:  BTFSC  03.0
08F9:  GOTO   124
08FA:  BSF    03.6
08FB:  MOVF   0C,W
08FC:  ANDLW  7F
08FD:  BCF    03.6
08FE:  MOVWF  37
08FF:  BSF    03.6
0900:  MOVF   0D,W
0901:  BCF    03.6
0902:  MOVWF  38
0903:  BSF    03.6
0904:  MOVF   0F,W
0905:  BCF    03.6
0906:  MOVWF  39
0907:  MOVF   37,W
0908:  MOVWF  43
0909:  BCF    0A.3
090A:  CALL   1A7
090B:  BSF    0A.3
090C:  MOVF   38,W
090D:  BSF    03.6
090E:  MOVWF  0D
090F:  BCF    03.6
0910:  MOVF   39,W
0911:  BSF    03.6
0912:  MOVWF  0F
0913:  BCF    03.6
0914:  MOVF   0B,W
0915:  MOVWF  3A
0916:  BCF    0B.7
0917:  BSF    03.5
0918:  BSF    03.6
0919:  BSF    0C.7
091A:  BSF    0C.0
091B:  NOP
091C:  NOP
091D:  BCF    03.5
091E:  BCF    03.6
091F:  BTFSC  3A.7
0920:  BSF    0B.7
0921:  DECFSZ 36,F
0922:  GOTO   124
0923:  GOTO   145
0924:  BSF    03.6
0925:  RLF    0C,W
0926:  RLF    0E,W
0927:  ANDLW  7F
0928:  BCF    03.6
0929:  MOVWF  37
092A:  BSF    03.6
092B:  MOVF   0D,W
092C:  BCF    03.6
092D:  MOVWF  38
092E:  BSF    03.6
092F:  MOVF   0F,W
0930:  BCF    03.6
0931:  MOVWF  39
0932:  MOVF   37,W
0933:  MOVWF  43
0934:  BCF    0A.3
0935:  CALL   1A7
0936:  BSF    0A.3
0937:  MOVF   38,W
0938:  BSF    03.6
0939:  MOVWF  0D
093A:  BCF    03.6
093B:  MOVF   39,W
093C:  BSF    03.6
093D:  MOVWF  0F
093E:  INCF   0D,F
093F:  BTFSC  03.2
0940:  INCF   0F,F
0941:  BCF    03.0
0942:  BCF    03.6
0943:  DECFSZ 36,F
0944:  GOTO   0EB
....................  
.................... #list 
....................  
.................... #use delay(internal=8MHz) 
*
0020:  MOVLW  44
0021:  MOVWF  04
0022:  BCF    03.7
0023:  MOVF   00,W
0024:  BTFSC  03.2
0025:  GOTO   033
0026:  MOVLW  02
0027:  MOVWF  78
0028:  CLRF   77
0029:  DECFSZ 77,F
002A:  GOTO   029
002B:  DECFSZ 78,F
002C:  GOTO   028
002D:  MOVLW  97
002E:  MOVWF  77
002F:  DECFSZ 77,F
0030:  GOTO   02F
0031:  DECFSZ 00,F
0032:  GOTO   026
0033:  RETURN
*
0307:  MOVLW  08
0308:  SUBWF  40,F
0309:  BTFSS  03.0
030A:  GOTO   317
030B:  MOVLW  40
030C:  MOVWF  04
030D:  BCF    03.7
030E:  BCF    03.0
030F:  RRF    00,F
0310:  MOVF   00,W
0311:  BTFSC  03.2
0312:  GOTO   317
0313:  GOTO   315
0314:  NOP
0315:  DECFSZ 00,F
0316:  GOTO   314
0317:  RETURN
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0992:  BCF    03.6
0993:  CLRF   20
0994:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdbool.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                          stdbool.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard boolean definitions                                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __STDBOOL_H__ 
.................... #define __STDBOOL_H__ 
....................  
.................... //remove TRUE and FALSE added by CCS's device .h file 
.................... #if defined(TRUE) 
.................... #undef TRUE 
.................... #endif 
.................... #if defined(FALSE) 
.................... #undef FALSE 
.................... #endif 
....................  
.................... typedef int1   bool; 
.................... #define true   1 
.................... #define false  0 
.................... #define __bool_true_false_are_defined  1 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #use timer(tick=100us,bits=32,NOISR)     
*
02A3:  BTFSS  0C.0
02A4:  GOTO   2AF
02A5:  MOVLW  01
02A6:  ADDWF  22,F
02A7:  BTFSC  03.0
02A8:  INCF   23,F
02A9:  BTFSC  03.2
02AA:  INCF   24,F
02AB:  BTFSC  03.2
02AC:  INCF   25,F
02AD:  BCF    0C.0
02AE:  GOTO   2C3
02AF:  MOVF   0F,W
02B0:  MOVWF  7A
02B1:  MOVF   0E,W
02B2:  MOVWF  77
02B3:  MOVF   0F,W
02B4:  SUBWF  7A,W
02B5:  BTFSS  03.2
02B6:  GOTO   2AF
02B7:  MOVF   77,W
02B8:  BTFSS  0C.0
02B9:  GOTO   2CC
02BA:  MOVLW  01
02BB:  ADDWF  22,F
02BC:  BTFSC  03.0
02BD:  INCF   23,F
02BE:  BTFSC  03.2
02BF:  INCF   24,F
02C0:  BTFSC  03.2
02C1:  INCF   25,F
02C2:  BCF    0C.0
02C3:  MOVF   0F,W
02C4:  MOVWF  7A
02C5:  MOVF   0E,W
02C6:  MOVWF  77
02C7:  MOVF   0F,W
02C8:  SUBWF  7A,W
02C9:  BTFSS  03.2
02CA:  GOTO   2C3
02CB:  MOVF   77,W
02CC:  MOVWF  77
02CD:  MOVF   7A,W
02CE:  MOVWF  78
02CF:  MOVF   22,W
02D0:  MOVWF  79
02D1:  MOVF   23,W
02D2:  MOVWF  7A
02D3:  MOVF   24,W
02D4:  MOVWF  36
02D5:  RRF    36,F
02D6:  RRF    7A,F
02D7:  RRF    79,F
02D8:  RRF    78,F
02D9:  RRF    77,F
02DA:  RRF    36,F
02DB:  RRF    7A,F
02DC:  RRF    79,F
02DD:  RRF    78,F
02DE:  RRF    77,F
02DF:  RRF    36,F
02E0:  RRF    7A,F
02E1:  RRF    79,F
02E2:  RRF    78,F
02E3:  RRF    77,F
02E4:  RRF    36,F
02E5:  RRF    7A,F
02E6:  RRF    79,F
02E7:  RRF    78,F
02E8:  RRF    77,F
02E9:  RRF    36,F
02EA:  RRF    7A,F
02EB:  RRF    79,F
02EC:  RRF    78,F
02ED:  RRF    77,F
02EE:  RETURN
.................... #define TICK_TYPE unsigned int32     
....................  
.................... // define for pin in board----------------------------------------------------// 
.................... #define FAN   PIN_A1 
.................... #define LIGHT   PIN_A2 
.................... #define LED_DB   PIN_A3 
.................... #define BT1   PIN_A4 
.................... #define BT2   PIN_A5 
.................... #define LIGHT_ON() output_high(LIGHT); 
.................... #define LIGHT_OFF() output_low(LIGHT); 
.................... #define FAN_ON() output_high(FAN); 
.................... #define FAN_OFF() output_low(FAN); 
.................... // end define ----------------------------------------------------------------// 
....................  
.................... // define for LCD ------------------------------------------------------------// 
.................... #define ONE_WIRE_PIN PIN_A0 
.................... #define LCD_ENABLE_PIN PIN_C1 
.................... #define LCD_RS_PIN PIN_C3 
.................... #define LCD_RW_PIN PIN_C2 
.................... #define LCD_DATA4 PIN_C7 
.................... #define LCD_DATA5 PIN_C6 
.................... #define LCD_DATA6 PIN_C5 
.................... #define LCD_DATA7 PIN_C4 
.................... // define for LCD ------------------------------------------------------------// 
.................... #include "lcd.c" 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
00B9:  BSF    07.7
....................    output_float(LCD_DATA5); 
00BA:  BSF    07.6
....................    output_float(LCD_DATA6); 
00BB:  BSF    07.5
....................    output_float(LCD_DATA7); 
00BC:  BSF    07.4
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00BD:  BCF    03.5
00BE:  BSF    07.2
00BF:  BCF    26.2
00C0:  MOVF   26,W
00C1:  BSF    03.5
00C2:  MOVWF  07
....................    delay_cycles(1); 
00C3:  NOP
....................    lcd_output_enable(1); 
00C4:  BCF    03.5
00C5:  BSF    07.1
00C6:  BCF    26.1
00C7:  MOVF   26,W
00C8:  BSF    03.5
00C9:  MOVWF  07
....................    delay_cycles(1); 
00CA:  NOP
....................    high = lcd_read_nibble(); 
00CB:  BCF    03.5
00CC:  CALL   06C
00CD:  MOVF   78,W
00CE:  MOVWF  4B
....................        
....................    lcd_output_enable(0); 
00CF:  BCF    07.1
00D0:  BCF    26.1
00D1:  MOVF   26,W
00D2:  BSF    03.5
00D3:  MOVWF  07
....................    delay_cycles(1); 
00D4:  NOP
....................    lcd_output_enable(1); 
00D5:  BCF    03.5
00D6:  BSF    07.1
00D7:  BCF    26.1
00D8:  MOVF   26,W
00D9:  BSF    03.5
00DA:  MOVWF  07
....................    delay_us(1); 
00DB:  GOTO   0DC
....................    low = lcd_read_nibble(); 
00DC:  BCF    03.5
00DD:  CALL   06C
00DE:  MOVF   78,W
00DF:  MOVWF  4A
....................        
....................    lcd_output_enable(0); 
00E0:  BCF    07.1
00E1:  BCF    26.1
00E2:  MOVF   26,W
00E3:  BSF    03.5
00E4:  MOVWF  07
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
00E5:  BCF    03.5
00E6:  BCF    26.7
00E7:  MOVF   26,W
00E8:  BSF    03.5
00E9:  MOVWF  07
....................    output_drive(LCD_DATA5); 
00EA:  BCF    03.5
00EB:  BCF    26.6
00EC:  MOVF   26,W
00ED:  BSF    03.5
00EE:  MOVWF  07
....................    output_drive(LCD_DATA6); 
00EF:  BCF    03.5
00F0:  BCF    26.5
00F1:  MOVF   26,W
00F2:  BSF    03.5
00F3:  MOVWF  07
....................    output_drive(LCD_DATA7); 
00F4:  BCF    03.5
00F5:  BCF    26.4
00F6:  MOVF   26,W
00F7:  BSF    03.5
00F8:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
00F9:  BCF    03.5
00FA:  SWAPF  4B,W
00FB:  MOVWF  77
00FC:  MOVLW  F0
00FD:  ANDWF  77,F
00FE:  MOVF   77,W
00FF:  IORWF  4A,W
0100:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
006C:  CLRF   4C
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
006D:  BSF    26.7
006E:  MOVF   26,W
006F:  BSF    03.5
0070:  MOVWF  07
0071:  MOVLW  00
0072:  BCF    03.5
0073:  BTFSC  07.7
0074:  MOVLW  01
0075:  IORWF  4C,F
....................    n |= input(LCD_DATA5) << 1; 
0076:  BSF    26.6
0077:  MOVF   26,W
0078:  BSF    03.5
0079:  MOVWF  07
007A:  MOVLW  00
007B:  BCF    03.5
007C:  BTFSC  07.6
007D:  MOVLW  01
007E:  MOVWF  77
007F:  BCF    03.0
0080:  RLF    77,F
0081:  MOVF   77,W
0082:  IORWF  4C,F
....................    n |= input(LCD_DATA6) << 2; 
0083:  BSF    26.5
0084:  MOVF   26,W
0085:  BSF    03.5
0086:  MOVWF  07
0087:  MOVLW  00
0088:  BCF    03.5
0089:  BTFSC  07.5
008A:  MOVLW  01
008B:  MOVWF  77
008C:  RLF    77,F
008D:  RLF    77,F
008E:  MOVLW  FC
008F:  ANDWF  77,F
0090:  MOVF   77,W
0091:  IORWF  4C,F
....................    n |= input(LCD_DATA7) << 3; 
0092:  BSF    26.4
0093:  MOVF   26,W
0094:  BSF    03.5
0095:  MOVWF  07
0096:  MOVLW  00
0097:  BCF    03.5
0098:  BTFSC  07.4
0099:  MOVLW  01
009A:  MOVWF  77
009B:  RLF    77,F
009C:  RLF    77,F
009D:  RLF    77,F
009E:  MOVLW  F8
009F:  ANDWF  77,F
00A0:  MOVF   77,W
00A1:  IORWF  4C,F
....................     
....................    return(n); 
00A2:  MOVF   4C,W
00A3:  MOVWF  78
....................   #else 
00A4:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0034:  BTFSC  4B.0
0035:  GOTO   038
0036:  BCF    07.7
0037:  GOTO   039
0038:  BSF    07.7
0039:  BCF    26.7
003A:  MOVF   26,W
003B:  BSF    03.5
003C:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
003D:  BCF    03.5
003E:  BTFSC  4B.1
003F:  GOTO   042
0040:  BCF    07.6
0041:  GOTO   043
0042:  BSF    07.6
0043:  BCF    26.6
0044:  MOVF   26,W
0045:  BSF    03.5
0046:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0047:  BCF    03.5
0048:  BTFSC  4B.2
0049:  GOTO   04C
004A:  BCF    07.5
004B:  GOTO   04D
004C:  BSF    07.5
004D:  BCF    26.5
004E:  MOVF   26,W
004F:  BSF    03.5
0050:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0051:  BCF    03.5
0052:  BTFSC  4B.3
0053:  GOTO   056
0054:  BCF    07.4
0055:  GOTO   057
0056:  BSF    07.4
0057:  BCF    26.4
0058:  MOVF   26,W
0059:  BSF    03.5
005A:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
005B:  NOP
....................    lcd_output_enable(1); 
005C:  BCF    03.5
005D:  BSF    07.1
005E:  BCF    26.1
005F:  MOVF   26,W
0060:  BSF    03.5
0061:  MOVWF  07
....................    delay_us(2); 
0062:  GOTO   063
0063:  GOTO   064
....................    lcd_output_enable(0); 
0064:  BCF    03.5
0065:  BCF    07.1
0066:  BCF    26.1
0067:  MOVF   26,W
0068:  BSF    03.5
0069:  MOVWF  07
006A:  BCF    03.5
006B:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
00A5:  BCF    26.1
00A6:  MOVF   26,W
00A7:  BSF    03.5
00A8:  MOVWF  07
....................    lcd_rs_tris(); 
00A9:  BCF    03.5
00AA:  BCF    26.3
00AB:  MOVF   26,W
00AC:  BSF    03.5
00AD:  MOVWF  07
....................    lcd_rw_tris(); 
00AE:  BCF    03.5
00AF:  BCF    26.2
00B0:  MOVF   26,W
00B1:  BSF    03.5
00B2:  MOVWF  07
....................   #endif 
....................  
....................    lcd_output_rs(0); 
00B3:  BCF    03.5
00B4:  BCF    07.3
00B5:  BCF    26.3
00B6:  MOVF   26,W
00B7:  BSF    03.5
00B8:  MOVWF  07
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0101:  MOVF   78,W
0102:  MOVWF  4A
0103:  BTFSS  4A.7
0104:  GOTO   107
0105:  BSF    03.5
0106:  GOTO   0B9
....................    lcd_output_rs(address); 
0107:  MOVF   48,F
0108:  BTFSS  03.2
0109:  GOTO   10C
010A:  BCF    07.3
010B:  GOTO   10D
010C:  BSF    07.3
010D:  BCF    26.3
010E:  MOVF   26,W
010F:  BSF    03.5
0110:  MOVWF  07
....................    delay_cycles(1); 
0111:  NOP
....................    lcd_output_rw(0); 
0112:  BCF    03.5
0113:  BCF    07.2
0114:  BCF    26.2
0115:  MOVF   26,W
0116:  BSF    03.5
0117:  MOVWF  07
....................    delay_cycles(1); 
0118:  NOP
....................    lcd_output_enable(0); 
0119:  BCF    03.5
011A:  BCF    07.1
011B:  BCF    26.1
011C:  MOVF   26,W
011D:  BSF    03.5
011E:  MOVWF  07
....................    lcd_send_nibble(n >> 4); 
011F:  BCF    03.5
0120:  SWAPF  49,W
0121:  MOVWF  4A
0122:  MOVLW  0F
0123:  ANDWF  4A,F
0124:  MOVF   4A,W
0125:  MOVWF  4B
0126:  CALL   034
....................    lcd_send_nibble(n & 0xf); 
0127:  MOVF   49,W
0128:  ANDLW  0F
0129:  MOVWF  4A
012A:  MOVWF  4B
012B:  CALL   034
012C:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
012D:  MOVLW  28
012E:  MOVWF  37
012F:  MOVLW  0C
0130:  MOVWF  38
0131:  MOVLW  01
0132:  MOVWF  39
0133:  MOVLW  06
0134:  MOVWF  3A
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0135:  BCF    07.1
0136:  BCF    26.1
0137:  MOVF   26,W
0138:  BSF    03.5
0139:  MOVWF  07
....................    lcd_output_rs(0); 
013A:  BCF    03.5
013B:  BCF    07.3
013C:  BCF    26.3
013D:  MOVF   26,W
013E:  BSF    03.5
013F:  MOVWF  07
....................    lcd_output_rw(0); 
0140:  BCF    03.5
0141:  BCF    07.2
0142:  BCF    26.2
0143:  MOVF   26,W
0144:  BSF    03.5
0145:  MOVWF  07
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0146:  BCF    03.5
0147:  BCF    26.7
0148:  MOVF   26,W
0149:  BSF    03.5
014A:  MOVWF  07
....................    output_drive(LCD_DATA5); 
014B:  BCF    03.5
014C:  BCF    26.6
014D:  MOVF   26,W
014E:  BSF    03.5
014F:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0150:  BCF    03.5
0151:  BCF    26.5
0152:  MOVF   26,W
0153:  BSF    03.5
0154:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0155:  BCF    03.5
0156:  BCF    26.4
0157:  MOVF   26,W
0158:  BSF    03.5
0159:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
015A:  BCF    03.5
015B:  BCF    26.1
015C:  MOVF   26,W
015D:  BSF    03.5
015E:  MOVWF  07
....................    lcd_rs_tris(); 
015F:  BCF    03.5
0160:  BCF    26.3
0161:  MOVF   26,W
0162:  BSF    03.5
0163:  MOVWF  07
....................    lcd_rw_tris(); 
0164:  BCF    03.5
0165:  BCF    26.2
0166:  MOVF   26,W
0167:  BSF    03.5
0168:  MOVWF  07
....................  #endif 
....................      
....................    delay_ms(15); 
0169:  MOVLW  0F
016A:  BCF    03.5
016B:  MOVWF  44
016C:  CALL   020
....................    for(i=1;i<=3;++i) 
016D:  MOVLW  01
016E:  MOVWF  36
016F:  MOVF   36,W
0170:  SUBLW  03
0171:  BTFSS  03.0
0172:  GOTO   17B
....................    { 
....................        lcd_send_nibble(3); 
0173:  MOVLW  03
0174:  MOVWF  4B
0175:  CALL   034
....................        delay_ms(5); 
0176:  MOVLW  05
0177:  MOVWF  44
0178:  CALL   020
0179:  INCF   36,F
017A:  GOTO   16F
....................    } 
....................     
....................    lcd_send_nibble(2); 
017B:  MOVLW  02
017C:  MOVWF  4B
017D:  CALL   034
....................    delay_ms(5); 
017E:  MOVLW  05
017F:  MOVWF  44
0180:  CALL   020
....................    for(i=0;i<=3;++i) 
0181:  CLRF   36
0182:  MOVF   36,W
0183:  SUBLW  03
0184:  BTFSS  03.0
0185:  GOTO   192
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0186:  MOVLW  37
0187:  ADDWF  36,W
0188:  MOVWF  04
0189:  BCF    03.7
018A:  MOVF   00,W
018B:  MOVWF  3B
018C:  CLRF   48
018D:  MOVF   3B,W
018E:  MOVWF  49
018F:  CALL   0A5
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0190:  INCF   36,F
0191:  GOTO   182
0192:  BSF    0A.3
0193:  BCF    0A.4
0194:  GOTO   197 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
0195:  DECFSZ 45,W
0196:  GOTO   198
0197:  GOTO   19B
....................       address=LCD_LINE_TWO; 
0198:  MOVLW  40
0199:  MOVWF  46
019A:  GOTO   19C
....................    else 
....................       address=0; 
019B:  CLRF   46
....................       
....................    address+=x-1; 
019C:  MOVLW  01
019D:  SUBWF  44,W
019E:  ADDWF  46,F
....................    lcd_send_byte(0,0x80|address); 
019F:  MOVF   46,W
01A0:  IORLW  80
01A1:  MOVWF  47
01A2:  CLRF   48
01A3:  MOVF   47,W
01A4:  MOVWF  49
01A5:  CALL   0A5
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01A6:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
01A7:  MOVF   43,W
01A8:  XORLW  07
01A9:  BTFSC  03.2
01AA:  GOTO   1B5
01AB:  XORLW  0B
01AC:  BTFSC  03.2
01AD:  GOTO   1BA
01AE:  XORLW  06
01AF:  BTFSC  03.2
01B0:  GOTO   1C2
01B1:  XORLW  02
01B2:  BTFSC  03.2
01B3:  GOTO   1C8
01B4:  GOTO   1CD
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
01B5:  MOVLW  01
01B6:  MOVWF  44
01B7:  MOVWF  45
01B8:  CALL   195
01B9:  GOTO   1D2
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
01BA:  CLRF   48
01BB:  MOVLW  01
01BC:  MOVWF  49
01BD:  CALL   0A5
....................                      delay_ms(2); 
01BE:  MOVLW  02
01BF:  MOVWF  44
01C0:  CALL   020
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
01C1:  GOTO   1D2
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
01C2:  MOVLW  01
01C3:  MOVWF  44
01C4:  MOVLW  02
01C5:  MOVWF  45
01C6:  CALL   195
01C7:  GOTO   1D2
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
01C8:  CLRF   48
01C9:  MOVLW  10
01CA:  MOVWF  49
01CB:  CALL   0A5
01CC:  GOTO   1D2
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
01CD:  MOVLW  01
01CE:  MOVWF  48
01CF:  MOVF   43,W
01D0:  MOVWF  49
01D1:  CALL   0A5
....................      #endif 
....................    } 
01D2:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #use rs232(baud=9600, xmit=PIN_B6,rcv= PIN_B7,parity=n,bits = 8) 
*
0229:  BSF    03.5
022A:  BCF    06.6
022B:  BCF    03.5
022C:  BCF    06.6
022D:  MOVLW  08
022E:  MOVWF  78
022F:  GOTO   230
0230:  NOP
0231:  BSF    78.7
0232:  GOTO   241
0233:  BCF    78.7
0234:  RRF    43,F
0235:  BTFSC  03.0
0236:  BSF    06.6
0237:  BTFSS  03.0
0238:  BCF    06.6
0239:  BSF    78.6
023A:  GOTO   241
023B:  BCF    78.6
023C:  DECFSZ 78,F
023D:  GOTO   234
023E:  GOTO   23F
023F:  NOP
0240:  BSF    06.6
0241:  MOVLW  3F
0242:  MOVWF  04
0243:  DECFSZ 04,F
0244:  GOTO   243
0245:  NOP
0246:  BTFSC  78.7
0247:  GOTO   233
0248:  BTFSC  78.6
0249:  GOTO   23B
024A:  RETURN
*
07D2:  BSF    03.5
07D3:  BSF    06.7
07D4:  BCF    03.5
07D5:  BTFSC  06.7
07D6:  GOTO   7D5
07D7:  MOVLW  08
07D8:  MOVWF  77
07D9:  CLRF   36
07DA:  BSF    77.7
07DB:  GOTO   7EA
07DC:  BCF    77.7
07DD:  GOTO   7EA
07DE:  BCF    03.0
07DF:  BTFSC  06.7
07E0:  BSF    03.0
07E1:  RRF    36,F
07E2:  BSF    77.6
07E3:  GOTO   7EA
07E4:  BCF    77.6
07E5:  DECFSZ 77,F
07E6:  GOTO   7DE
07E7:  MOVF   36,W
07E8:  MOVWF  78
07E9:  GOTO   7F5
07EA:  MOVLW  3F
07EB:  BTFSC  77.7
07EC:  MOVLW  11
07ED:  MOVWF  78
07EE:  DECFSZ 78,F
07EF:  GOTO   7EE
07F0:  BTFSC  77.7
07F1:  GOTO   7DC
07F2:  BTFSC  77.6
07F3:  GOTO   7E4
07F4:  GOTO   7DE
07F5:  BSF    0A.3
07F6:  BCF    0A.4
07F7:  GOTO   227 (RETURN)
.................... /* 
....................  *  
....................  */ 
.................... bool fan_state; 
.................... bool light_state; 
.................... int  temp_setpoint; 
.................... float  temp_current; 
.................... bool auto_hand; 
.................... TICK_TYPE GetTickDifference(TICK_TYPE currTick, TICK_TYPE prevTick) 
.................... { 
.................... 	return(currTick-prevTick); 
*
02EF:  MOVF   3A,W
02F0:  SUBWF  36,W
02F1:  MOVWF  77
02F2:  MOVF   37,W
02F3:  MOVWF  78
02F4:  MOVF   3B,W
02F5:  BTFSS  03.0
02F6:  INCFSZ 3B,W
02F7:  SUBWF  78,F
02F8:  MOVF   38,W
02F9:  MOVWF  79
02FA:  MOVF   3C,W
02FB:  BTFSS  03.0
02FC:  INCFSZ 3C,W
02FD:  SUBWF  79,F
02FE:  MOVF   39,W
02FF:  MOVWF  7A
0300:  MOVF   3D,W
0301:  BTFSS  03.0
0302:  INCFSZ 3D,W
0303:  SUBWF  7A,F
0304:  BSF    0A.3
0305:  BCF    0A.4
0306:  GOTO   1EB (RETURN)
.................... }         
.................... void onewire_reset() { 
....................     output_low(ONE_WIRE_PIN); 
*
0318:  BSF    03.5
0319:  BCF    05.0
031A:  BCF    03.5
031B:  BCF    05.0
....................     delay_us(500); 
031C:  MOVLW  02
031D:  MOVWF  3F
031E:  MOVLW  F8
031F:  MOVWF  40
0320:  CALL   307
0321:  DECFSZ 3F,F
0322:  GOTO   31E
....................     output_float(ONE_WIRE_PIN); 
0323:  BSF    03.5
0324:  BSF    05.0
....................     delay_us(500); 
0325:  MOVLW  02
0326:  BCF    03.5
0327:  MOVWF  3F
0328:  MOVLW  F8
0329:  MOVWF  40
032A:  CALL   307
032B:  DECFSZ 3F,F
032C:  GOTO   328
....................     output_float(ONE_WIRE_PIN); 
032D:  BSF    03.5
032E:  BSF    05.0
032F:  BCF    03.5
0330:  RETURN
.................... } 
.................... void onewire_write(int8 data) { 
....................     int8 count; 
....................  
....................     for(count = 0; count < 8; ++count) { 
0331:  CLRF   40
0332:  MOVF   40,W
0333:  SUBLW  07
0334:  BTFSS  03.0
0335:  GOTO   350
....................         output_low(ONE_WIRE_PIN); 
0336:  BSF    03.5
0337:  BCF    05.0
0338:  BCF    03.5
0339:  BCF    05.0
....................         delay_us(2); 
033A:  GOTO   33B
033B:  GOTO   33C
....................         output_bit(ONE_WIRE_PIN, shift_right(&data, 1, 0)); 
033C:  BCF    03.0
033D:  RRF    3F,F
033E:  BTFSC  03.0
033F:  GOTO   342
0340:  BCF    05.0
0341:  GOTO   343
0342:  BSF    05.0
0343:  BSF    03.5
0344:  BCF    05.0
....................         delay_us(60); 
0345:  MOVLW  27
0346:  MOVWF  77
0347:  DECFSZ 77,F
0348:  GOTO   347
0349:  GOTO   34A
....................         output_float(ONE_WIRE_PIN); 
034A:  BSF    05.0
....................         delay_us(2); 
034B:  GOTO   34C
034C:  GOTO   34D
034D:  BCF    03.5
034E:  INCF   40,F
034F:  GOTO   332
....................     } 
0350:  RETURN
.................... } 
.................... int onewire_read() { 
....................     int count, data; 
....................  
....................     for(count = 0; count < 8; ++count) { 
0351:  CLRF   3F
0352:  MOVF   3F,W
0353:  SUBLW  07
0354:  BTFSS  03.0
0355:  GOTO   373
....................         output_low(ONE_WIRE_PIN); 
0356:  BSF    03.5
0357:  BCF    05.0
0358:  BCF    03.5
0359:  BCF    05.0
....................         delay_us(2); 
035A:  GOTO   35B
035B:  GOTO   35C
....................         output_float(ONE_WIRE_PIN); 
035C:  BSF    03.5
035D:  BSF    05.0
....................         delay_us(8); 
035E:  MOVLW  04
035F:  MOVWF  77
0360:  DECFSZ 77,F
0361:  GOTO   360
0362:  GOTO   363
0363:  NOP
....................         shift_right(&data, 1, input(ONE_WIRE_PIN)); 
0364:  BSF    05.0
0365:  BCF    03.5
0366:  BTFSC  05.0
0367:  GOTO   36A
0368:  BCF    03.0
0369:  GOTO   36B
036A:  BSF    03.0
036B:  RRF    40,F
....................         delay_us(120); 
036C:  MOVLW  4F
036D:  MOVWF  77
036E:  DECFSZ 77,F
036F:  GOTO   36E
0370:  GOTO   371
0371:  INCF   3F,F
0372:  GOTO   352
....................     } 
....................     return data; 
0373:  MOVF   40,W
0374:  MOVWF  78
0375:  RETURN
.................... }  
.................... float ds1820_read() { 
0376:  CLRF   36
....................     int8 busy=0, temp1, temp2; 
....................     signed int16 temp3; 
....................     float result; 
....................     onewire_reset(); 
0377:  CALL   318
....................     onewire_write(0xCC); 
0378:  MOVLW  CC
0379:  MOVWF  3F
037A:  CALL   331
....................     onewire_write(0x44); 
037B:  MOVLW  44
037C:  MOVWF  3F
037D:  CALL   331
....................     while(busy == 0) 
037E:  MOVF   36,F
037F:  BTFSS  03.2
0380:  GOTO   385
....................         busy = onewire_read(); 
0381:  CALL   351
0382:  MOVF   78,W
0383:  MOVWF  36
0384:  GOTO   37E
....................     onewire_reset(); 
0385:  CALL   318
....................     onewire_write(0xCC); 
0386:  MOVLW  CC
0387:  MOVWF  3F
0388:  CALL   331
....................     onewire_write(0xBE);  
0389:  MOVLW  BE
038A:  MOVWF  3F
038B:  CALL   331
....................     temp1 = onewire_read(); 
038C:  CALL   351
038D:  MOVF   78,W
038E:  MOVWF  37
....................     temp2 = onewire_read(); 
038F:  CALL   351
0390:  MOVF   78,W
0391:  MOVWF  38
....................     temp3 = make16(temp2, temp1); 
0392:  MOVF   38,W
0393:  MOVWF  3A
0394:  MOVF   37,W
0395:  MOVWF  39
....................     result = (float) temp3 / 16.0; 
0396:  MOVF   3A,W
0397:  MOVWF  40
0398:  MOVF   39,W
0399:  MOVWF  3F
*
03BE:  MOVF   7A,W
03BF:  MOVWF  42
03C0:  MOVF   79,W
03C1:  MOVWF  41
03C2:  MOVF   78,W
03C3:  MOVWF  40
03C4:  MOVF   77,W
03C5:  MOVWF  3F
03C6:  MOVF   42,W
03C7:  MOVWF  46
03C8:  MOVF   41,W
03C9:  MOVWF  45
03CA:  MOVF   40,W
03CB:  MOVWF  44
03CC:  MOVF   3F,W
03CD:  MOVWF  43
03CE:  CLRF   4A
03CF:  CLRF   49
03D0:  CLRF   48
03D1:  MOVLW  83
03D2:  MOVWF  47
*
049C:  MOVF   7A,W
049D:  MOVWF  3E
049E:  MOVF   79,W
049F:  MOVWF  3D
04A0:  MOVF   78,W
04A1:  MOVWF  3C
04A2:  MOVF   77,W
04A3:  MOVWF  3B
....................     delay_ms(200); 
04A4:  MOVLW  C8
04A5:  MOVWF  44
04A6:  CALL   020
....................     return(result); 
04A7:  MOVF   3B,W
04A8:  MOVWF  77
04A9:  MOVF   3C,W
04AA:  MOVWF  78
04AB:  MOVF   3D,W
04AC:  MOVWF  79
04AD:  MOVF   3E,W
04AE:  MOVWF  7A
04AF:  BSF    0A.3
04B0:  BCF    0A.4
04B1:  GOTO   207 (RETURN)
.................... } 
.................... void ds1820_configure(int8 TH, int8 TL, int8 config) { 
....................     onewire_reset(); 
....................     onewire_write(0xCC); 
....................     onewire_write(0x4E); 
....................     onewire_write(TH); 
....................     onewire_write(TL); 
....................     onewire_write(config); 
.................... } 
.................... void display(); 
.................... void check_temp(); 
.................... void main( void ) 
*
0969:  MOVF   03,W
096A:  ANDLW  1F
096B:  MOVWF  03
096C:  MOVLW  71
096D:  BSF    03.5
096E:  MOVWF  0F
096F:  CLRF   10
0970:  MOVF   0F,W
0971:  BCF    03.5
0972:  CLRF   25
0973:  CLRF   24
0974:  CLRF   23
0975:  CLRF   22
0976:  MOVLW  B5
0977:  MOVWF  10
0978:  CLRF   0E
0979:  CLRF   0F
097A:  CLRF   0E
097B:  BCF    0C.0
097C:  MOVLW  FF
097D:  MOVWF  26
097E:  BSF    03.5
097F:  BCF    06.6
0980:  BCF    03.5
0981:  BSF    06.6
0982:  BSF    03.5
0983:  BSF    03.6
0984:  MOVF   09,W
0985:  ANDLW  C0
0986:  MOVWF  09
0987:  BCF    03.6
0988:  BCF    1F.4
0989:  BCF    1F.5
098A:  MOVLW  00
098B:  BSF    03.6
098C:  MOVWF  08
098D:  BCF    03.5
098E:  CLRF   07
098F:  CLRF   08
0990:  CLRF   09
0991:  BCF    03.7
.................... { 
....................     lcd_init(); 
*
0995:  BCF    0A.3
0996:  GOTO   12D
0997:  BSF    0A.3
....................     char s; 
....................     lcd_putc("\f"); 
0998:  MOVLW  04
0999:  BSF    03.6
099A:  MOVWF  0D
099B:  MOVLW  00
099C:  MOVWF  0F
099D:  BCF    0A.3
099E:  BCF    03.6
099F:  CALL   1D3
09A0:  BSF    0A.3
....................     puts("START"); 
09A1:  MOVLW  05
09A2:  BSF    03.6
09A3:  MOVWF  0D
09A4:  MOVLW  00
09A5:  MOVWF  0F
09A6:  BCF    0A.3
09A7:  BCF    03.6
09A8:  GOTO   24B
09A9:  BSF    0A.3
09AA:  MOVLW  0D
09AB:  MOVWF  43
09AC:  BCF    0A.3
09AD:  CALL   229
09AE:  BSF    0A.3
09AF:  MOVLW  0A
09B0:  MOVWF  43
09B1:  BCF    0A.3
09B2:  CALL   229
09B3:  BSF    0A.3
....................     fan_state = false; 
09B4:  BCF    27.0
....................     light_state = false; 
09B5:  BCF    27.1
....................     temp_current = 0; 
09B6:  CLRF   2C
09B7:  CLRF   2B
09B8:  CLRF   2A
09B9:  CLRF   29
....................     temp_setpoint = 0; 
09BA:  CLRF   28
....................      
....................     TICK_TYPE CurrentTick,PreviousTick; 
....................     //Example program using Tick Timer 
.................... 	CurrentTick = PreviousTick = get_ticks();  
09BB:  BCF    0A.3
09BC:  CALL   2A3
09BD:  BSF    0A.3
09BE:  MOVF   7A,W
09BF:  MOVWF  35
09C0:  MOVF   79,W
09C1:  MOVWF  34
09C2:  MOVF   78,W
09C3:  MOVWF  33
09C4:  MOVF   77,W
09C5:  MOVWF  32
09C6:  MOVF   35,W
09C7:  MOVWF  31
09C8:  MOVF   34,W
09C9:  MOVWF  30
09CA:  MOVF   33,W
09CB:  MOVWF  2F
09CC:  MOVF   32,W
09CD:  MOVWF  2E
....................     while(TRUE)  
....................     { 
....................         CurrentTick = get_ticks(); 
09CE:  BCF    0A.3
09CF:  CALL   2A3
09D0:  BSF    0A.3
09D1:  MOVF   7A,W
09D2:  MOVWF  31
09D3:  MOVF   79,W
09D4:  MOVWF  30
09D5:  MOVF   78,W
09D6:  MOVWF  2F
09D7:  MOVF   77,W
09D8:  MOVWF  2E
....................                                       
.................... 		if(GetTickDifference(CurrentTick, PreviousTick) >= (TICK_TYPE)TICKS_PER_SECOND) 
09D9:  MOVF   31,W
09DA:  MOVWF  39
09DB:  MOVF   30,W
09DC:  MOVWF  38
09DD:  MOVF   2F,W
09DE:  MOVWF  37
09DF:  MOVF   2E,W
09E0:  MOVWF  36
09E1:  MOVF   35,W
09E2:  MOVWF  3D
09E3:  MOVF   34,W
09E4:  MOVWF  3C
09E5:  MOVF   33,W
09E6:  MOVWF  3B
09E7:  MOVF   32,W
09E8:  MOVWF  3A
09E9:  BCF    0A.3
09EA:  GOTO   2EF
09EB:  BSF    0A.3
09EC:  MOVF   7A,W
09ED:  MOVWF  39
09EE:  MOVF   79,W
09EF:  MOVWF  38
09F0:  MOVF   78,W
09F1:  MOVWF  37
09F2:  MOVF   77,W
09F3:  MOVWF  36
09F4:  MOVF   39,F
09F5:  BTFSS  03.2
09F6:  GOTO   205
09F7:  MOVF   38,F
09F8:  BTFSS  03.2
09F9:  GOTO   205
09FA:  MOVF   37,W
09FB:  SUBLW  1D
09FC:  BTFSC  03.0
09FD:  GOTO   219
09FE:  XORLW  FF
09FF:  BTFSS  03.2
0A00:  GOTO   205
0A01:  MOVF   36,W
0A02:  SUBLW  83
0A03:  BTFSC  03.0
0A04:  GOTO   219
.................... 		{			 
....................             temp_current = ds1820_read(); 
0A05:  BCF    0A.3
0A06:  GOTO   376
0A07:  BSF    0A.3
0A08:  MOVF   7A,W
0A09:  MOVWF  2C
0A0A:  MOVF   79,W
0A0B:  MOVWF  2B
0A0C:  MOVF   78,W
0A0D:  MOVWF  2A
0A0E:  MOVF   77,W
0A0F:  MOVWF  29
....................             display(); 
0A10:  CALL   000
.................... 			PreviousTick = CurrentTick; 
0A11:  MOVF   31,W
0A12:  MOVWF  35
0A13:  MOVF   30,W
0A14:  MOVWF  34
0A15:  MOVF   2F,W
0A16:  MOVWF  33
0A17:  MOVF   2E,W
0A18:  MOVWF  32
.................... 		} 
....................         if(input(BT1) == 0) 
0A19:  BSF    03.5
0A1A:  BSF    05.4
0A1B:  BCF    03.5
0A1C:  BTFSS  05.4
....................         { 
....................             auto_hand = true; 
0A1D:  BSF    27.2
....................         } 
....................         if(input(BT2) == 0) 
0A1E:  BSF    03.5
0A1F:  BSF    05.5
0A20:  BCF    03.5
0A21:  BTFSS  05.5
....................         { 
....................             auto_hand = false; 
0A22:  BCF    27.2
....................         } 
....................         if (kbhit()) 
0A23:  BTFSC  06.7
0A24:  GOTO   2AB
....................         { 
....................             s = getc();           
0A25:  BCF    0A.3
0A26:  GOTO   7D2
0A27:  BSF    0A.3
0A28:  MOVF   78,W
0A29:  MOVWF  2D
....................             switch(s) 
0A2A:  MOVF   2D,W
0A2B:  XORLW  31
0A2C:  BTFSC  03.2
0A2D:  GOTO   253
0A2E:  XORLW  03
0A2F:  BTFSC  03.2
0A30:  GOTO   259
0A31:  XORLW  01
0A32:  BTFSC  03.2
0A33:  GOTO   25F
0A34:  XORLW  07
0A35:  BTFSC  03.2
0A36:  GOTO   265
0A37:  XORLW  01
0A38:  BTFSC  03.2
0A39:  GOTO   26B
0A3A:  XORLW  03
0A3B:  BTFSC  03.2
0A3C:  GOTO   272
0A3D:  XORLW  01
0A3E:  BTFSC  03.2
0A3F:  GOTO   279
0A40:  XORLW  0F
0A41:  BTFSC  03.2
0A42:  GOTO   280
0A43:  XORLW  01
0A44:  BTFSC  03.2
0A45:  GOTO   287
0A46:  XORLW  48
0A47:  BTFSC  03.2
0A48:  GOTO   28E
0A49:  XORLW  06
0A4A:  BTFSC  03.2
0A4B:  GOTO   295
0A4C:  XORLW  12
0A4D:  BTFSC  03.2
0A4E:  GOTO   29C
0A4F:  XORLW  17
0A50:  BTFSC  03.2
0A51:  GOTO   2A3
0A52:  GOTO   2AA
....................             {             
....................  
....................                 case '1': 
....................                 { 
....................                     fan_state = true; 
0A53:  BSF    27.0
....................                     check_temp(); 
0A54:  BCF    0A.3
0A55:  CALL   4B2
0A56:  BSF    0A.3
....................                     display(); 
0A57:  CALL   000
....................                     break; 
0A58:  GOTO   2AA
....................                 } 
....................                 case '2': 
....................                 { 
....................                     fan_state = false; 
0A59:  BCF    27.0
....................                     check_temp(); 
0A5A:  BCF    0A.3
0A5B:  CALL   4B2
0A5C:  BSF    0A.3
....................                     display(); 
0A5D:  CALL   000
....................                     break; 
0A5E:  GOTO   2AA
....................                 } 
....................                 case '3': 
....................                 { 
....................                     light_state = true; 
0A5F:  BSF    27.1
....................                     check_temp(); 
0A60:  BCF    0A.3
0A61:  CALL   4B2
0A62:  BSF    0A.3
....................                     display(); 
0A63:  CALL   000
....................                     break; 
0A64:  GOTO   2AA
....................                 } 
....................                 case '4': 
....................                 { 
....................                     light_state = false; 
0A65:  BCF    27.1
....................                     check_temp(); 
0A66:  BCF    0A.3
0A67:  CALL   4B2
0A68:  BSF    0A.3
....................                     display(); 
0A69:  CALL   000
....................                     break; 
0A6A:  GOTO   2AA
....................                 } 
....................                 case '5': 
....................                 { 
....................                     temp_setpoint = 23; 
0A6B:  MOVLW  17
0A6C:  MOVWF  28
....................                     check_temp(); 
0A6D:  BCF    0A.3
0A6E:  CALL   4B2
0A6F:  BSF    0A.3
....................                     display(); 
0A70:  CALL   000
....................                     break; 
0A71:  GOTO   2AA
....................                 } 
....................                 case '6': 
....................                 { 
....................                     temp_setpoint = 24; 
0A72:  MOVLW  18
0A73:  MOVWF  28
....................                     check_temp(); 
0A74:  BCF    0A.3
0A75:  CALL   4B2
0A76:  BSF    0A.3
....................                     display(); 
0A77:  CALL   000
....................                     break; 
0A78:  GOTO   2AA
....................                 } 
....................                 case '7': 
....................                 { 
....................                     temp_setpoint = 25; 
0A79:  MOVLW  19
0A7A:  MOVWF  28
....................                     check_temp(); 
0A7B:  BCF    0A.3
0A7C:  CALL   4B2
0A7D:  BSF    0A.3
....................                     display(); 
0A7E:  CALL   000
....................                     break; 
0A7F:  GOTO   2AA
....................                 } 
....................                 case '8': 
....................                 { 
....................                     temp_setpoint = 26; 
0A80:  MOVLW  1A
0A81:  MOVWF  28
....................                     check_temp(); 
0A82:  BCF    0A.3
0A83:  CALL   4B2
0A84:  BSF    0A.3
....................                     display(); 
0A85:  CALL   000
....................                     break; 
0A86:  GOTO   2AA
....................                 } 
....................                 case '9': 
....................                 { 
....................                     temp_setpoint = 27; 
0A87:  MOVLW  1B
0A88:  MOVWF  28
....................                     check_temp(); 
0A89:  BCF    0A.3
0A8A:  CALL   4B2
0A8B:  BSF    0A.3
....................                     display(); 
0A8C:  CALL   000
....................                     break; 
0A8D:  GOTO   2AA
....................                 } 
....................                 case 'q': 
....................                 { 
....................                     temp_setpoint = 28; 
0A8E:  MOVLW  1C
0A8F:  MOVWF  28
....................                     check_temp(); 
0A90:  BCF    0A.3
0A91:  CALL   4B2
0A92:  BSF    0A.3
....................                     display(); 
0A93:  CALL   000
....................                     break; 
0A94:  GOTO   2AA
....................                 } 
....................                 case 'w': 
....................                 { 
....................                     temp_setpoint = 29; 
0A95:  MOVLW  1D
0A96:  MOVWF  28
....................                     check_temp(); 
0A97:  BCF    0A.3
0A98:  CALL   4B2
0A99:  BSF    0A.3
....................                     display(); 
0A9A:  CALL   000
....................                     break; 
0A9B:  GOTO   2AA
....................                 } 
....................                 case 'e': 
....................                 { 
....................                     temp_setpoint = 30; 
0A9C:  MOVLW  1E
0A9D:  MOVWF  28
....................                     check_temp(); 
0A9E:  BCF    0A.3
0A9F:  CALL   4B2
0AA0:  BSF    0A.3
....................                     display(); 
0AA1:  CALL   000
....................                     break; 
0AA2:  GOTO   2AA
....................                 } 
....................                 case 'r': 
....................                 { 
....................                     temp_setpoint = 31; 
0AA3:  MOVLW  1F
0AA4:  MOVWF  28
....................                     check_temp(); 
0AA5:  BCF    0A.3
0AA6:  CALL   4B2
0AA7:  BSF    0A.3
....................                     display(); 
0AA8:  CALL   000
....................                     break; 
0AA9:  GOTO   2AA
....................                 } 
....................                 default: 
....................                 { 
....................                     break; 
....................                 } 
....................             } 
....................             s = NULL; 
0AAA:  CLRF   2D
....................         } 
0AAB:  GOTO   1CE
....................          
....................     } 
.................... } 
....................  
0AAC:  SLEEP
.................... void display() 
.................... { 
....................     check_temp(); 
*
0800:  BCF    0A.3
0801:  CALL   4B2
0802:  BSF    0A.3
....................     lcd_putc("\f"); 
0803:  MOVLW  08
0804:  BSF    03.6
0805:  MOVWF  0D
0806:  MOVLW  00
0807:  MOVWF  0F
0808:  BCF    0A.3
0809:  BCF    03.6
080A:  CALL   1D3
080B:  BSF    0A.3
....................     if(fan_state == true) 
080C:  BTFSS  27.0
080D:  GOTO   01D
....................     { 
....................         lcd_gotoxy(0,0); // line top 
080E:  CLRF   44
080F:  CLRF   45
0810:  BCF    0A.3
0811:  CALL   195
0812:  BSF    0A.3
....................         lcd_putc("F-ON"); 
0813:  MOVLW  09
0814:  BSF    03.6
0815:  MOVWF  0D
0816:  MOVLW  00
0817:  MOVWF  0F
0818:  BCF    0A.3
0819:  BCF    03.6
081A:  CALL   1D3
081B:  BSF    0A.3
....................     } 
081C:  GOTO   02B
....................     else 
....................     { 
....................         lcd_gotoxy(0,0); // line top 
081D:  CLRF   44
081E:  CLRF   45
081F:  BCF    0A.3
0820:  CALL   195
0821:  BSF    0A.3
....................         lcd_putc("F-OFF"); 
0822:  MOVLW  0C
0823:  BSF    03.6
0824:  MOVWF  0D
0825:  MOVLW  00
0826:  MOVWF  0F
0827:  BCF    0A.3
0828:  BCF    03.6
0829:  CALL   1D3
082A:  BSF    0A.3
....................     } 
....................     if(light_state == true) 
082B:  BTFSS  27.1
082C:  GOTO   03D
....................     { 
....................         lcd_gotoxy(8,0); // line top 
082D:  MOVLW  08
082E:  MOVWF  44
082F:  CLRF   45
0830:  BCF    0A.3
0831:  CALL   195
0832:  BSF    0A.3
....................         lcd_putc("L-ON"); 
0833:  MOVLW  0F
0834:  BSF    03.6
0835:  MOVWF  0D
0836:  MOVLW  00
0837:  MOVWF  0F
0838:  BCF    0A.3
0839:  BCF    03.6
083A:  CALL   1D3
083B:  BSF    0A.3
....................     } 
083C:  GOTO   04C
....................     else 
....................     { 
....................         lcd_gotoxy(8,0); // line top 
083D:  MOVLW  08
083E:  MOVWF  44
083F:  CLRF   45
0840:  BCF    0A.3
0841:  CALL   195
0842:  BSF    0A.3
....................         lcd_putc("L-OFF"); 
0843:  MOVLW  12
0844:  BSF    03.6
0845:  MOVWF  0D
0846:  MOVLW  00
0847:  MOVWF  0F
0848:  BCF    0A.3
0849:  BCF    03.6
084A:  CALL   1D3
084B:  BSF    0A.3
....................     } 
....................     lcd_gotoxy(15,0); 
084C:  MOVLW  0F
084D:  MOVWF  44
084E:  CLRF   45
084F:  BCF    0A.3
0850:  CALL   195
0851:  BSF    0A.3
....................     if(auto_hand) 
0852:  BTFSS  27.2
0853:  GOTO   05E
....................     { 
....................         lcd_putc("A"); 
0854:  MOVLW  15
0855:  BSF    03.6
0856:  MOVWF  0D
0857:  MOVLW  00
0858:  MOVWF  0F
0859:  BCF    0A.3
085A:  BCF    03.6
085B:  CALL   1D3
085C:  BSF    0A.3
....................     } 
085D:  GOTO   067
....................     else 
....................     { 
....................         lcd_putc("H"); 
085E:  MOVLW  16
085F:  BSF    03.6
0860:  MOVWF  0D
0861:  MOVLW  00
0862:  MOVWF  0F
0863:  BCF    0A.3
0864:  BCF    03.6
0865:  CALL   1D3
0866:  BSF    0A.3
....................     } 
....................     lcd_gotoxy(0,1); // line botton 
0867:  CLRF   44
0868:  MOVLW  01
0869:  MOVWF  45
086A:  BCF    0A.3
086B:  CALL   195
086C:  BSF    0A.3
....................     printf(lcd_putc,"SP-%d   CR-%3.1f",temp_setpoint,temp_current); 
086D:  MOVLW  53
086E:  MOVWF  43
086F:  BCF    0A.3
0870:  CALL   1A7
0871:  BSF    0A.3
0872:  MOVLW  50
0873:  MOVWF  43
0874:  BCF    0A.3
0875:  CALL   1A7
0876:  BSF    0A.3
0877:  MOVLW  2D
0878:  MOVWF  43
0879:  BCF    0A.3
087A:  CALL   1A7
087B:  BSF    0A.3
087C:  MOVF   28,W
087D:  MOVWF  36
087E:  MOVLW  18
087F:  MOVWF  37
*
08E2:  MOVLW  19
08E3:  BSF    03.6
08E4:  MOVWF  0D
08E5:  MOVLW  00
08E6:  MOVWF  0F
08E7:  BSF    03.0
08E8:  MOVLW  06
08E9:  BCF    03.6
08EA:  MOVWF  36
*
0945:  MOVLW  02
0946:  MOVWF  04
0947:  MOVF   2C,W
0948:  MOVWF  39
0949:  MOVF   2B,W
094A:  MOVWF  38
094B:  MOVF   2A,W
094C:  MOVWF  37
094D:  MOVF   29,W
094E:  MOVWF  36
094F:  MOVLW  01
0950:  MOVWF  3A
0951:  BCF    0A.3
0952:  GOTO   648
0953:  BSF    0A.3
....................     printf("%3.1f\n",temp_current); 
0954:  MOVLW  02
0955:  MOVWF  04
0956:  MOVF   2C,W
0957:  MOVWF  39
0958:  MOVF   2B,W
0959:  MOVWF  38
095A:  MOVF   2A,W
095B:  MOVWF  37
095C:  MOVF   29,W
095D:  MOVWF  36
095E:  MOVLW  01
095F:  MOVWF  3A
0960:  BCF    0A.3
0961:  GOTO   70D
0962:  BSF    0A.3
0963:  MOVLW  0A
0964:  MOVWF  43
0965:  BCF    0A.3
0966:  CALL   229
0967:  BSF    0A.3
0968:  RETURN
.................... } 
.................... void check_temp() 
.................... { 
....................     if(auto_hand) 
*
04B2:  BTFSS  27.2
04B3:  GOTO   539
....................     { 
....................         if(temp_setpoint > temp_current) 
04B4:  CLRF   37
04B5:  MOVF   28,W
04B6:  MOVWF  36
*
04D3:  MOVF   2C,W
04D4:  MOVWF  39
04D5:  MOVF   2B,W
04D6:  MOVWF  38
04D7:  MOVF   2A,W
04D8:  MOVWF  37
04D9:  MOVF   29,W
04DA:  MOVWF  36
04DB:  MOVF   7A,W
04DC:  MOVWF  3D
04DD:  MOVF   79,W
04DE:  MOVWF  3C
04DF:  MOVF   78,W
04E0:  MOVWF  3B
04E1:  MOVF   77,W
04E2:  MOVWF  3A
*
0521:  BTFSS  03.0
0522:  GOTO   52E
....................         { 
....................             FAN_ON(); 
0523:  BSF    03.5
0524:  BCF    05.1
0525:  BCF    03.5
0526:  BSF    05.1
....................             fan_state = true; 
0527:  BSF    27.0
....................             LIGHT_ON(); 
0528:  BSF    03.5
0529:  BCF    05.2
052A:  BCF    03.5
052B:  BSF    05.2
....................             light_state = true; 
052C:  BSF    27.1
....................         } 
052D:  GOTO   538
....................         else 
....................         { 
....................             FAN_OFF(); 
052E:  BSF    03.5
052F:  BCF    05.1
0530:  BCF    03.5
0531:  BCF    05.1
....................             fan_state = false; 
0532:  BCF    27.0
....................             LIGHT_OFF(); 
0533:  BSF    03.5
0534:  BCF    05.2
0535:  BCF    03.5
0536:  BCF    05.2
....................             light_state = false; 
0537:  BCF    27.1
....................         } 
....................     } 
0538:  GOTO   54F
....................     else 
....................     { 
....................         if(fan_state)  
0539:  BTFSS  27.0
053A:  GOTO   540
....................         {FAN_ON();} 
053B:  BSF    03.5
053C:  BCF    05.1
053D:  BCF    03.5
053E:  BSF    05.1
053F:  GOTO   544
....................         else {FAN_OFF();} 
0540:  BSF    03.5
0541:  BCF    05.1
0542:  BCF    03.5
0543:  BCF    05.1
....................         if(light_state) {LIGHT_ON();} 
0544:  BTFSS  27.1
0545:  GOTO   54B
0546:  BSF    03.5
0547:  BCF    05.2
0548:  BCF    03.5
0549:  BSF    05.2
054A:  GOTO   54F
....................         else 
....................         {LIGHT_OFF();} 
054B:  BSF    03.5
054C:  BCF    05.2
054D:  BCF    03.5
054E:  BCF    05.2
....................     } 
054F:  RETURN
.................... } 

Configuration Fuses:
   Word  1: 2FE4   INTRC_IO NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
